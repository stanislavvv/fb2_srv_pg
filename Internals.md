# Краткое описание чего и как делается

[[__TOC__]]


## Создание списков книг (первый этап индексации)

Списки книг `.zip.list` представляют собой данные о каждом `.fb2`, находящемся в соответствующем `.zip`, по одной записи на строку.
Формат jsonl, т.е. отдельный json на строку.

Производится:

  * `./datachew.sh lists` — пересоздание всех списков с нуля
  * `./datachew.sh new_lists` — создание списков для новых/изменившихся `.zip`

Из каждого `.zip` в `data` будет извлекаться каждый `.fb2`, после чего:

  1. Получаются метаданные (ветка `FictionBook.description`), оттуда берутся поля:
    * `title-info.author` — структура, содержащая данные автора (преобразуется в строку)
    * `title-info.book-title` — название книги
    * `title-info.coverpage` — указатель на изображение-обложку (после вытаскивания изображения не используется)
    * `title-info.genre` — жанр или несколько
    * `title-info.lang` — язык
    * `title-info.sequence` — структура, определяющая серию книг и номер книги в серии
    * `title-info.annotation` — аннотация книги (сохраняется как кусок html)
    * `publish-info` — структура, где могут быть (или не быть): год издания, ISBN, наименование издательства
  2. Вытаскивается картинка, соответствующая `title-info.coverpage`, размер изменяется до 300 по ширине и преобразуется в base64
  3. Создаётся структура данных о книге, которая пишется в виде строки json в `.zip.list`, соответствующий `.zip`

Используемые функции (из `data_chew.*`, верхние уровни вызовов):

  * `update_booklist` — проверка на новизну `.zip` или `.zip.replace` и возможный вызов `create_booklist`
  * `create_booklist` — безусловное создание списка книг. Вызывает:
    - `list_zip` — получение списка файлов в `.zip`
    - `get_inpx_meta` — получение метаданных из `.inpx`, если есть
    - `get_replace_list` — получение замен метаданных из `.zip.replace`
    - `fb2_parse` — разбор одной отдельно взятой книги из `.zip`


## Заполнение БД (второй этап индексации)

Производится:

  * `./datachew.sh fillall` — загрузка всех данных из `.zip.list` в БД с перезаписью данных для имеющихся книг
  * `./datachew.sh fillonly` — загрузка только новых книг

Каждая строка из каждого `.zip.list` проверяется на наличие в БД и либо при отсутствии просто добавляется БД, либо:

  * параметр `fillall` — делается UPDATE для соответствующих записей книги, серии, автора
  * параметр `fillonly` — книга пропускается

Параллельно собираются данные для серий книг и принадлежности авторам.

По окончании загрузки книг производится пересчёт данных о количестве книг у авторов, в сериях и в жанрах.

Запросы к базе находятся в `data_chew/consts.py`, обращение к базе идёт через класс `BookDB` из `data_chew/db.py`

Основные вызываемые функции (верхние уровни вызовов из `data_chew.*`):

  * `process_list` — обработка файлов `.zip.list`, полученных на предыдущем этапе. Предварительно прогоняет создание таблиц через `BookDB.create_tables`. Вызывает:
    - `process_list_books_batch` — обработка записей о книгах батчами размером около или менее PASS_SIZE_HINT, для каждого батча вызывается:
      * `process_books_batch` — обработка батча записей, выделение авторов, серий, информации об издательстве, обложек, запись в БД
    - `recalc_commit` — пересчёт количества книг у авторов, в сериях, в жанрах и завершение транзакции


## opds/html интерфейс

Приложение на flask, два интерфейса:
  * opds, он же xml, скопирован с интерфейса Флибусты (см. `app/views_opds.py`).
  * html, представляет собой данные для opds, пропущенные через html-темплейты, а не преобразованные в xml (см. `app/views_html.py`).

Оба интерфейса используют одни и те же функции из `app/views_internals.py`, представляющие собой спецобёртку над функциями из `app/opds.py`

Чтение и скачивание книг определяется в `app/views_dl.py`, функции:
  * `fb2_read` — возвращает `text/html` для чтения в браузере (производит преобразование fb2 в html)
  * `fb2_download` — возвращает `.fb2.zip` (берёт соответствующий файл из общего `.zip` и запаковывает в отдельный `.zip` на лету)
  * `fb2_cover` — возвращает jpeg-изображение обложки из базы, либо изображение по-умолчанию.

Пути к методам html создаются заменой `/opds` на `/html`, так что константу `URL` в `app/consts.py` следует править очень аккуратно.
Темплейты для интерфейса html можно найти в каталоге `app/templates`, из них используются:

  * `base.html`— основной темплейт, задаёт внешний вид, заголовок и подвал каждой страницы
  * `opds_root.html` — темплейт для простого списка строк, в частности корня интерфейса html
  * `opds_list_linecnt.html` — темплейт для списка строк со счетчиками
  * `opds_author_main.html` — темплейт для основной страницы автора
  * `opds_sequence.html` — темплейт для серий книг (в том числе и для серий конкретного автора)

Само приложение запускается из корня как `./opds.sh` для режима разработчика или `./gunicorn.sh` для прода, но это не догма.
Выбор режима осуществляется заданием переменной окружения `FLASK_ENV`, возможные значения `development` и `prod`.

Настройки для разных режимов задаются в `app/config.py`, в соответствующих секциях.
В примере `app/config.py.example` — в DevelopmentConfig меньшая длина страниц и приложение отвечает от "/", а не от "/books".
Секция TestConfig — на вырост, если таки соберусь сделать автотесты.
